# JavaScript基础

**Hint**:以下所有代码的执行环境为**Chrome**或**Node.js**

### 常用函数

* `alert()` : 弹出一个警告框。该函数返回值为`undefined`。

  ```javascript
  alert("警告");
  ```

* `console.log()` : 控制台打印日志

  ```javascript
  console.log("Hello World!");
  ```

* `confirm()` : 选择`确定`或是`取消`，返回`true`或`false`，类型为`boolean`

  ```javascript
  var ret = confirm("Have you ever read the book?");
  console.log(ret);
  ```

* `prompt()` : 提示输入，返回值类型为`string`

  ```javascript
  username = prompt("Please input you name: ");
  console.log(username);
  ```

### JavaScript代码的编写位置

* 事件触发中

    ```html
    <html>
    <head>
        <meta charset="UTF-8"/>
        <title></title>
    </head>
    <body>
        <button onclick="alert('Hello World');">点击</button>
    </body>
    </html>
    ```

* 超链接标签属性中

    ```html
    <html>
    <head>
        <meta charset="UTF-8"/>
        <title></title>
    </head>
    <body>
        <a href="javascript:alert('Hello World.');">点我</a>
    </body>
    </html>
    ```

* `<script>`标签中

    ```html
    <html>
    <head>
        <meta charset="UTF-8"/>
        <title></title>
        <script type="text/javascript">
            alert("Hello World.");
        </script>
    </head>
    <body>
    </body>
    </html>
    ```

* `<script>`标签引用外部文件

    ```html
    <html>
    <head>
        <meta charset="UTF-8"/>
        <title></title>
        <script type="text/javascript" src="./js/script.js"></script>
    </head>
    <body>
    </body>
    </html>
    ```

    注意，一旦使用`script`标签引用外部js文件，就不能再在该标签中写js的代码。

### 注释

1. 单行注释

    ```javascript
    // ...
    ```

2. 多行注释

    ```javascript
    /*
     ...
     */
    ```

### 规则

* JavaScript严格区分大小写。

* JavaScript中每一条语句以分号(;)结尾，虽然可以不写，浏览器会自动加上分号，但是一般推荐写分号，减少浏览器的资源消耗，也防止加错分号。

* JavaScript中会忽略多个空格和换行，所以利用空格和换行进行格式化。

* 编码风格采用驼峰式命名法。

### 字面量和变量

* **字面量**是不可改变的值。但一般我们不会直接使用字面量。

* **变量**可以用来保存字面量，而且变量的值是可以任意改变的，变量更加方便使用。

### 标识符

命名一个标识符需要遵守以下规则:

* 标识符只能由数字、字母、下划线、$组成

* 标识符不能以数字开头

* 标识符不能是ES中的关键字或保留字

* 标识符一般采用驼峰命名法

* JavaScript底层保存标识符时实际上采用的Unicode编码，所以理论上讲所有utf-8中含有的内容都可以作为标识符

### 数据类型

查看数据类型我们可以使用`typeof`，返回值为字符串类型。

* 基本数据类型

  * **string** : 字符串

    可以使用单引号引起来，也可以使用双引号引起来，但不能混用。  

  * **number** : 数值类型

    * 最大可以表示的0以上的浮点数范围: `Number.MIN_VALUE`(5e-324) ~ `Number.MAX_VALUE`(1.7976931348623157e+308)

    * `NaN` : 表示not a number。如`a = "abc" * "bcd";`，此时a就是`NaN`。使用`typeof`检查时返回的是`number`

    * `Infinity`和`-Infitiny`

    * 整数运算基本可以保证精确性，但是浮点数的运算不能保证精度。千万不要使用JavaScript进行对精度要求高的运算。

  * **boolean** : 布尔类型

    `true` and `false`

  * **null** : 空值

    `null`专门用来表示一个为空的对象。使用`typeof`判断结果是`object`。

  * **undefined** : 未定义

    当声明一个变量但不给它赋值时，它的值就是`undefined`。如果不声明就取一个变量的值，则会报错。

* 引用数据类型

  * **object** : 对象类型

### 其他进制的数字

* 十六进制 : 以`0x`开头

  ```javascript
  a = 0x10;
  a = 0xff;
  a = 0xCafe;
  ```

* 八进制 : 以`0`开头

  ```javascript
  a = 070;
  ```

* 二进制 : 以`0b`开头

  ```javascript
  a = 0b10;
  ```

### 数据类型的转换

类型转换主要指将其他数据类型转换成string、number、boolean。

* 将其他数据类型转换为string

  * 方法1: 调用被转换类型的`toString()`方法，当变量值为null或undefined时将会报错。

  * 方法2: 调用`String()`函数。对于`number`和`boolean`类型来讲，实际上调用的是`toString()`方法，对于`null`和`undefined`，则直接转换为`string`

* 将其他数据类型转换为number

  * 转换方式1: 使用`Number()`函数

    `string`转`number`:

    * 如果是纯数字字符串，则直接将其转换为数字
    * 如果字符串中有非数字的内容，则转换为`NaN`
    * 如果字符串为空串，或全是空格，则转换为0

    `boolean`转`number`:

    * `true` 转成 1
    * `false` 转成 0

    `null`转`number`: 结果为0

    `undefined`转`number`: 结果为`NaN`

  * 转换方式2: 专门针对字符串

    * `parseInt()`: 把一个字符串转换成整数。从左向右扫描至非数字字符结束，去除有效的整数。如果开始就是非数字字符，则返回`NaN`。可以用该函数取整。该函数可以传递第二个参数，指定第一个参数为几进制。

    * `parseFloat()`: 把一个字符串转化成浮点数。从左向右扫描，取出有效的小数。如果开始就是非数字字符，则返回`NaN`

    以上两个方法，在参数为非字符串时，会先将参数转换为字符串，再进行从左到右的扫描。

  * 将其他的数据类型转换为`boolean`类型

    调用`Boolean()`函数，结果只有两种值: `true` 和 `false`:

    * 将数值类型转换为`boolean`类型时，仅当值为`0`和`NaN`时，转换结果为`false`，其他为`true`

    * 将字符串转换为`boolean`类型时，仅当字符串为空串时，转换结果为`false`，其他均为`true`。

    * 将`null`和`undefined`转换为`boolean`时都是`false`。

    * 对象会转换为`true`。

### 运算符(操作符)

#### 算数运算符

算数运算符 | 描述
-- | --
+ | 加/字符串拼接
- | 减
* | 乘
/ | 除
% | 取余

注意: 任何值和字符串做+操作都会先将其转换成字符串再进行拼接操作。任何值和`NaN`运算都得`NaN`。将任意数据类型的数据转换成字符串只需要将其与空字符串拼接(隐式类型转换)。除了`+`中的运算数为字符串时做的是拼接操作，其他都是转化成`number`类型再做运算。

#### 一元操作符

* `-` : 负号
* `+` : 正号

  上述两个一元操作符可以使任意数据类型转换为`number`类型，原理是`Number()`函数。

* `++` : 自增
* `--` : 自减

  注意区分`a++`,`++a`,`a--`,`--a`。

* typeof : 获取字面量或变量的类型，返回类型为`string`。

#### 逻辑运算符

* `&&` : 与。惰性(短路的与)

* `||` : 或。惰性(短路的或)

* `!` : 非。如果对非布尔值进行取反运算，则会先将非布尔值转换为布尔值，再进行非运算。

非布尔值的与或运算:

* 与运算: 如果第一个值隐式转换为`true`，则返回第二个值。如果第一个值的隐式转换为`false`，则返回第一个值。

* 或运算: 如果第一个值隐式转换为`true`，则返回第一个值。如果第一个值隐式转换为`false`，则返回第二个值。

#### 赋值运算符

* =
* +=
* -=
* *=
* /=
* %=

#### 关系运算符

* `>`
* `>=`
* `<`
* `<=`


  返回值为`true`或`false`

### Unicode编码

JavaScript代码中使用`\uxxxx`来表示Unicode表示的码点，`xxxx`为4位十六进制数。在HTML中使用`&#...;`来表示Unicode码点，`...`为十进制数。

### 相等运算符

用于比较两个值是否相等，返回值为true或false。

* `==` : 相等
* `!=` : 不等
* `===` : 全等
* `!==` : 不全等

当使用相等运算符(`==`, `!=`)进行比较时，如果操作数的类型不相同，则会将它们转换成相同的类型，再进行比较。如`"1" == 1`的结果为`true`，`true == 1`的结果为`true`。 但是`null == 0`的结果则为`false`。

```javascript
console.log('1' == 1);     // true
console.log('1' == true);  // true
console.log(null == 0);    // false
```

`undefined`衍生自`null`，所以`undefined == null`的结果为`true`。

```javascript
console.log(undefined == null); // true
```

`NaN`不和任何值相等，包括它本身，即:

```javascript
console.log(NaN == NaN); //false
```

如果要判断一个值是否时`NaN`，使用`isNaN()`函数，而不能使用`==`。该函数当参数不为`number`类型时会先将参数转换成`number`再进行判断。

`===`和`!==`不会进行自动的类型转换。

```javascript
console.log("1" === 1);          // false
console.log(undefined === null); //false
```

### 条件运算符

条件运算符又叫三元运算符。`条件表达式 ? 语句1 : 语句2`。先对条件表达式进行求值，如果该值为`true`，则执行语句1，否则执行语句2，**并返回结果**。

### 运算符优先级

先介绍一个新的运算符: `,`。在声明变量时使用`,`可以同时声明多个变量。

在JS中有一个运算符优先级的表，在表中越靠上优先级越高，优先级越高越先计算。

运算符优先级表:

![](images/1.png)

### 代码块

我们的程序是由一条一条的语句构成的。语句是按照自上向下的顺序一条一条执行的，在JS中可以使用`{ }`来为语句分组。同一个`{}`中的语句称为一组语句，它们要么都执行，要么都不执行。一个`{}`中的语句也称为代码块。JS中的代码块只具有分组的作用，没有其它的用途。代码块内部的内容在外部是完全可见的。即:

```javascript
{
    var a = 10;
    alert("hello");
    console.log("你好");
}

console.log("a = " + a); //不报错，结果为 10
```

### 流程控制

#### 选择

* `if`单分支

  ```javascript
  if (condition) {
      ...
  }
  ```

* `if`两分支

  ```javascript
  if (condition) {
      ...
  } else {
      ...
  }
  ```

* `if`多分支

  ```javascript
  if (condition1) {
      ...
  } else if (condition2) {
      ...
  } else if (condition3) {
      ...
  } else {
      ...
  }
  ```

* `switch`多分支

  ```javascript
  switch(value) {
      case value1:
          ...;
          break;
      case value2:
          ...;
          break;
      ...
      default:
          ...
  }
  ```

  `switch`语句会将`value`的值依次与`value1`、`value2`、...进行**全等**比较，如果全等，则进入该条件执行语句，否则继续向下进行全等比较。

  这里需要注意一点，整数运算结果可能会是浮点数，如`99 / 10`的结果是`9.9`，而不是`9`。

  `switch`还可以有如下方式:

  ```javascript
  switch(true) {
      case 条件表达式1:
          ...
          break;
      case 条件表达式2:
          ...
          break;
      ...
      default:
          ...
  }
  ```

#### 循环

* `while`循环

  ```javascript
  while (条件表达式) {
      ....
  }
  ```

* `do-while`循环

  ```javascript
  do {
      ....
  } while (条件表达式);
  ```

* `for`循环

  ```javascript
  for (初始化表达式; 条件表达式; 更新表达式) {

  }
  ```

* `continue` 和 `break`

  `continue` : 退出本次循环，继续下一次循环

  `break` : 退出循环。

  还可以使用Label跳出多层循环，与Java非常相似。

* 计时器

  `console.time("name")` 和 `console.timeEnd("name")`

### 函数

函数也是一个对象。函数中可以封装一些功能(代码)，在需要时可以执行这些功能(代码)。函数中可以保存一些代码在需要的时候调用。


#### 函数的定义和调用

**创建**函数对象:


```js
var fun = new Function();
console.log(fun);                 //function
console.log(typeof fun);          //[Function: anonymous]
```

可以将要封装的代码以字符串的形式传递给构造函数:

```js
var fun = new Function("console.log('Hello, this is my first function!');");
```

封装到函数中的代码不会立即执行。函数中的代码会在调用的时候执行。调用语法: `函数对象()`。当调用函数时，函数中的代码会按照顺序执行。

```js
fun();          //Hello, this is my first function!
fun();          //Hello, this is my first function!
fun();          //Hello, this is my first function!
```

函数对象具有普通对象的所有功能，而且比普通对象强大，因为可以封装可执行的代码。

```js
fun.name = 'hello';
console.log(fun.name);  //hello
```

但是上述方法定义函数并不常用，常用的是使用**函数声明**来创建一个函数。语法: `function 函数名([形参1, 形参2, ..., 形参n]) {
    ...
}`

```js
function sayHello() {
    console.log('Hello');
}
//调用
sayHello();      //Hello
```

使用函数表达式创建函数: `var 函数名 = function([形参1, 形参2, ..., 形参n]) {...};`。实际上是将**匿名函数**赋值给一个**变量**。

```js
var sayHello = function() {
    console.log('Hello');
}
//调用
sayHello();       //Hello
```

调用函数时，**解析器不会检查实参的类型**，所以要注意，是否可能接收到非法的参数，如果有可能需要对参数进行类型的检查。**解析器也不会检查实参的数量**，而多余的参数不会被赋值，如果实参的数量少于形参的数量，则没有对应实参的形参将会是`undefined`。

#### 形参

函数的形参相当于在函数作用域使用`var`关键字声明变量。

#### 函数的返回值

可以使用`return`返回函数的执行结果。

```js
function sum(a, b, c) {
    return a + b + c;
}

var ret = sum (10, 20, 30);
console.log(ret);  //60
```

在函数中`return`之后的语句都不会执行。

如果`return`后面不跟任何值，则返回值是`undefined`，相当于不写`return`语句。

```js
function sayHello() {
    console.log("hello");
    return;
}

var ret = sayHello();
console.log(ret);    //undefined
```

函数的返回值可以是任何数据类型，包括对象。

#### 练习

* 定义一个函数，判断一个数字是否是偶数，如果是返回`true`，否则返回`false`

  ```js
  function isOdd(num) {
      return num % 2 == 0;
  }
  ```

* 定义一个函数，可以根据半径计算一个圆的面积并返回结果

  ```js
  function area(r) {
      return Math.PI * r * r;
  }
  ```

* 定义一个函数，可以在控制台输出一个人的信息，可以输出人的姓名，年龄，性别和地址

  ```js
  function information(name, age, gender, address) {
      console.log("我叫" + name + "， 今年" + age + "岁，" + gender + "，我住在" + address);
  }

  //使用对象作为参数
  var obj = {
      name: "孙悟空",
      age: 18,
      gender: "男",
      address: "花果山"
  };

  function information2(person) {
      console.log("我叫" + person.name + "， 今年" + person.age + "岁，" + person.gender + "，我住在" + person.address);
  }
  ```

#### 函数作为参数

函数也是一个对象，对象能干的事，函数都能干。

```js
function fun(a) {
    a();
}

function sayHello() {
    console.log("Hello");
}

//调用
fun(sayHello)                           //Hello

//传递匿名函数
fun(function(){console.log("Hello")})   //Hello
```

#### 函数调用和函数对象

* sayHello : 函数对象，作为参数就是将函数对象作为实参。
* sayHello() : 函数调用，作为参数就是将返回值作为实参。

#### 函数内部可以声明函数

```js
function fun1() {
    function fun2() {
        alert("我是fun2");
    }

    //调用
    fun2();

    //返回fun2
    return fun2;
}

var fun = fun1();
fun();            //相当于fun2();
```

#### 立即执行函数

* 无参函数

    ```js
    (function() {
        alert("我是一个匿名函数");
    })();
    ```

* 有参函数

    ```js
    (function(a, b) {
        console.log("a = " + a);
        console.log("b = " + b);
    })(12, 34);
    ```

### 对象

基本数据类型五种 : number, string, boolean, null, undefined。只要不是以上五种数据类型，那就是对象类型。

对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性。

#### 对象的分类:

* **内建对象** : 由ES标准定义的对象，在任何的ES的实现中都可以使用(JavaScript, Node.js)。如: Math, String, Number, Boolean, Function, Object等。

* **宿主对象** : 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。如: BOM, DOM。

* **自定义对象** : 由开发人员自己创建的对象。

#### 对象的操作

使用`new`关键字调用的函数，是构造函数`constructor`。

```javascript
var obj = new Object();
```

在对象中保存的值称为**属性**。

```javascript
obj.name = "Carlos Leo";
obj.age = 20;
obj.gender = true;
```

读取对象中的属性: `对象.属性名`。如果读取对象中没有的属性，不会报错，而是返回`undefined`。

```javascript
console.log(obj.name);    //Carlos Leo
console.log(obj.age);     //20
console.log(obj.gender);  //true

console.log(obj.class);   //undefined
```

修改对象的属性值: `对象.属性名 = 新值`

```javascript
obj.age = 19;
console.log(obj.age);     //19
```

删除对象的属性: `delete 对象.属性名`

```javascript
delete obj.gender;
console.log(obj.gender);   //undefined
console.log(obj.age);      //19
```

**注意**: 对象的属性名不强制要求遵守标识符的规范。但是尽量使用标识符的规范去做。

```javascript
obj.name = "孙悟空";
obj.var = "hello";
console.log(obj.var);      //hello
```

但是:

```javascript
obj.123 = 456;             //报错
```

如果需要特殊的属性名，不能采用`.`的方式来操作，需要使用另一种方式: `对象["属性名"]`。

```javascript
obj["123"] = 456;
console.log(obj["123"]);    //456
```

使用`[]`这种形式去操作对象的属性更加灵活，而且`[]`中可以传递一个变量，这样变量值是多少就会读取对应的属性。

```javascript
obj["123"] = 789;
var n = "123";
console.log(obj[n]);         //789
```

JS对象的属性值，可以是任意的数据类型。

```js
obj.test = true;
obj.test = null;
obj.test = undefined;

var kite = new Object();
kite.name = "Kite";
obj.test = kite;
console.log(obj.test.name);   //Kite
```

`in`运算符: 检查某个对象中是否有某个属性。返回值为`boolean`类型。

```javascript
console.log("test" in obj);   //true
```

#### 基本数据类型和引用类型

基本数据类型:

```js
var a = 123;
var b = a;
a++;
console.log("a = " + a);       //a = 124
console.log("b = " + b);       //b = 123
```

引用数据类型:

```js
var obj = new Object();
obj.name = "John";
var obj2 = obj;
obj.name = "Jenny";
console.log("obj.name = " + obj.name);     //obj.name = Jenny
console.log("obj2.name = " + obj2.name);   //obj2.name = Jenny
```

JS中的**变量**都是保存在**栈内存**中的。基本数据类型的值直接在栈内存中存储，值与值之间独立存在，修改一个变量不会影响其他的变量。

**对象**是保存在**堆内存**中的。对象变量保存的值是一个地址值，该地址指向堆内存上某个地址空间。每创建一个新的对象，就会在堆内存中开辟出一个新的空间。如果两个变量保存的是同一个对象引用，当通过一个变量改变对象的值时，另一个也会受影响。

切断一个变量与对象之间的联系:

```js
obj2 = null;
```

只有当两个变量指向同一个变量时，才会使得使用`==`判断的结果为`true`。而仅仅是内容相同则不会。

#### 对象字面量

创建对象的方式除了使用`new`关键字和构造方法外，还可以使用如下方式:

```js
var obj = {};
```

在使用以上方式创建对象时，可以直接指定对象中的属性和值:

```js
var obj = {
    name: "Carlos Leo",
    age: 18,
    gender: true
};
```

以上方式更加常用。而且属性名可以加`""`，但是推荐上不加，除非使用特殊的符号，如`123`,`#@$`等等作为属性名。属性名和属性值是一组一组的键值对结构，多个键值对之间使用`,`隔开。最后一个属性后面不需要写`,`。如果是JSON格式的数据，属性名需加上`""`。

#### 方法

对象的属性值可以是一个函数。如果一个函数作为一个对象的属性保存，那么我们称这个函数是该对象的方法，调用该函数就是调用对象的方法。但它只是名称上的区别。

```js
var obj = new Object();
obj.name = "孙悟空";
obj.age = 18;
obj.sayName = function(){
    console.log(obj.name);
}

//调用方法
obj.sayName();        //孙悟空

obj2 = {
    name: "Carlos Leo",
    age: 18,
    sayName: function(){
        ...
    }
};
```

#### 枚举对象中的属性

如果我们直接使用别人定义的对象，但是不知道对象具体的属性，我们可以枚举对象中的属性。

```js
//定义一个对象
var obj = {
    name: "Carlos Leo",
    age: 18,
    gender: true,
    sayHello: function() {
        console.log("Hello World!");
    }
}

//枚举对象中的属性
for (var n in obj) {
    console.log(n + " : " + obj[n]);
}

//输出结果
name : Carlos Leo
age : 18
gender : true
sayHello : function() {
        console.log("Hello World!");
    }
```

上述代码中枚举变量`n`的类型为`string`。

### 作用域

作用域指一个变量的作用范围。在JS中有两种作用域:

#### 全局作用域

  直接编写在`script`标签中的JS代码，全在全局作用域。全局作用域在页面打开时创建，在页面关闭时销毁。在全局作用域中有一个全局对象`window`，我们可以直接使用，它代表浏览器的窗口，由浏览器创建，是一个**宿主对象**。

  在全局作用域中，创建的变量会作为`window`对象的属性保存。

  ```js
  var a = 10;
  var b = 20;
  console.log(a, b);                 //10 20
  console.log(window.a, window.b);   //10 20
  ```

  在全局作用域中，创建的函数作为`window`对象的方法保存。

  ```js
  function fun() {
      console.log("我是fun函数");
  }
  
  fun();              //我是fun函数
  window.fun();       //我是fun函数
  ```

#### 函数作用域

  调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁。每调用一次函数就会创建一个新的函数作用域，它们之间是独立的。在函数作用域中可以访问到全局作用域变量，在全局作用域中不能访问到函数作用域。

  当在函数作用域中操作一个变量时，它先会在自己的作用域中寻找，如果有就直接使用，没有就向上一级寻找。直到全局作用域里也没有的话就报错。

  在函数中直接访问全局变量可以使用`window.变量`。

  在函数作用域中也有**变量提前声明**和**函数提前声明**。

  在函数中，不适用`var`声明的变量都会成为全局变量。

  ```js
  function fun() {
      d = 100;
  }
  console.log(d); //100
  ```

#### 变量的声明提前

使用`var`关键字声明的变量，会在所有的代码执行之前被声明(但是不会赋值)，直到执行到赋值语句时才会被赋值；如果不使用`var`关键字，则变量不会被提前声明。

```js
//使用var关键字声明变量
console.log(a);   //undefined
var a = 123;
console.log(a);   //123

//不适用var关键字声明变量
console.log(b);   //报错
b = 123;
```

#### 函数的声明提前

使用函数声明形式创建函数会在所有代码执行之前会被创建，所以我们可以在函数声明前调用函数。而使用匿名函数赋值给变量的形式创建函数，如果在创建之前调用该函数，则会报错。

```js
//不会报错
fun1()
function fun1() {
    console.log("函数声明创建函数")
}

//报错
fun2()
var fun2 = function() {
    console.log("匿名函数赋值给变量创建函数")
}
```

#### 练习

```js
var a = 123;
function fun() {
    console.log(a);
}
fun();

//output
123
```

```js
var a = 123;
function fun() {
    console.log(a);
    var a = 456;
}
fun();
console.log(a);

//output
undefined
123
```

```js
var a = 123;
function fun() {
    console.log(a);
    a = 456;
}
fun();
console.log(a);

//output
123
456
```

```js
var a = 123;
function fun(a) {
    console.log(a);
    a = 456;
}
fun();
console.log(a);

//output
undefined
123
```

```js
var a = 123;
function fun(a) {
    console.log(a);
    a = 456;
}
fun(123);
console.log(a);

//output
123
123
```

#### this

解析器在调用函数每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是`this`，`this`指向的是一个对象，这个对象称为函数执行的上下文对象。根据函数的调用方式不同，`this`会指向不同的对象。

```js
function fun() {
    console.log(this);
}
fun();

var obj = {
    name: "Carlos Leo",
    sayName: fun
};
obj.sayName();

//output:
Window
Object
```

上面的Object展开后是`{ name: 'cleo', sayName: [Function: fun] }`

* 以函数的形式调用，`this`永远都是`Window`。

* 以方法的形式调用时，`this`就是调用方法的对象。

```js
var name = "全局";
function fun() {
    console.log(this.name);
}
var obj = {
    name: "孙悟空",
    sayName: fun
}
var obj2 = {
    name: "沙和尚",
    sayName: fun
}
fun();
obj.sayName();
obj2.sayName();

//output: Chrome
全局
孙悟空
沙和尚

//output: Node.js
undefined
孙悟空
沙和尚
```

### 使用工厂方法创建对象

```js
function createPerson(name, age, gender) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    obj.gender = gender;
    obj.sayName = function(){
        alert(this.name);
    };
    return obj;
}

var person1 = createPerson("Carlos", 18, true);
var person2 = createPerson("Leo", 20, false);
```

### 构造函数

构造函数就是一个普通的函数，创建的方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。构造函数和普通函数的调用方式不同，普通函数直接调用，而构造函数需要使用`new`关键字来调用。

```js
//创建一个构造函数，专门用来创建Person对象
function Person() {
    console.log(this);
}

var person = new Person();

console.log(person);

//output: Node.js
Person {}
Person {}
```

构造函数的执行流程:

1. 立刻建立一个新的对象

2. 将新建的对象设置为函数中的`this`，在构造函数中可以使用`this`来引用新对象

3. 逐行执行函数中的代码

4. 将新建的对象作为返回值返回

以上4步中只有第三步我们看得到，其他的步骤均由浏览器完成。

```js
function Person(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.sayName = function() {
        console.log(this.name);
    };
}

var person = new Person("cleo", 20, true);
console.log(person);

//output: Node.js
Person { name: 'cleo', age: 20, gender: true, sayName: [Function] }
```

上述代码执行结果不再是`Object`，而是`Person`。变量`person`所指对象就是`Person`类的实例，而类就是构造函数。使用`instanceof`可以检查一个对象是否是一个类的实例。

```js
console.log(person instanceof Person);   //true
console.log(person instanceof Object);   //true
```

所有的对象都是`Object`的实例，因此所有的对象使用`instanceof`对`Object`运算一定返回`true`。

#### 构造函数的修改

我们先来看一段代码:

```js
function Person(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.sayName = function() {
        console.log(this.name);
    }
}

var person1 = new Person("Jenny", 24, true);
var person2 = new Person("Henry", 20, false);

console.log(person1.sayName == person2.sayName);    //false
```

上面的代码执行的结果为`false`。由此可以看出，构造方法每执行一次，就会创建一个新的`sayName`方法，所有实例的`sayName`都是唯一的。这就导致了构造函数执行一次就会创建一个新的方法，而这些方法的功能都是一样的。这样完全没有必要，完全可以使用所有对象共享一个方法。

```js
function Person(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.sayName = fun;
}

function fun() {
    console.log(this.name);
}

var person1 = new Person("Jenny", 24, true);
var person2 = new Person("Henry", 20, false);

console.log(person1.sayName == person2.sayName);    //true
```

修改成上述代码后，执行结果为`true`，而且实现了所有实例的方法共享，节省了内存空间，提高了性能。但是这样写又会有一些新的问题。**将函数定义在全局作用域中，污染了全局作用域的命名空间**。而且定义在全局作用域中也**很不安全**。

#### 原型

我们所创建的每一个函数，解析器都会向函数中添加一个属性`prototype`，这个属性对应一个对象，这个对象就对应一个原型对象。

如果函数作为普通函数调用，`prototype`没有任何作用。当函数以构造构造函数的形式调用时，新建的对象和原来的构造函数都会有一个隐含的属性指向该构造函数的原型对象，我们可以通过`__proto__`来访问该属性。

```js
function MyClass() {

}

var mc = new MyClass();
var mc2 = new MyClass();

console.log(mc.__proto__ == MyClass.prototype);   //true
console.log(mc2.__proto__ == MyClass.prototype);  //true
```

原型对象就相当于公共的区域，所有同一个类的实例都可以访问到这个原型对象。我们可以将对象中共有的内容，统一设置到原型对象中。

当我们访问对象中的属性的或方法时，先去该对象中寻找，如果没有，就去原型对象中寻找。

```js
function MyClass() {
    
}
MyClass.prototype.a = 123;

var obj1 = new MyClass();
console.log(obj1.a);        //123

var obj2 = new MyClass();
obj2.a = "hello";
console.log(obj2.a);        //hello
```

因此我们可以将共享的属性和方法保存到原型中，这样就不会污染全局作用域。

```js
//向原型中添加方法
function Person(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
}

Person.prototype.sayHello = function() {
    console.log(this.name);
}

var person = new Person("carlos", 20, true);
person.sayName();     //carlos
```

使用`in`检查对象中是否有某个属性时，如果对象中没有但是原型中有，也会返回`true`。

```js
console.log("sayName" in person);   //true
```

可以使用`hasOwnProperty()`方法来检查自身中是否有某个属性。只有当对象自身中含有某个属性时，才会返回`true`。

```js
console.log(person.hasOwnProperty("sayName"));  //false
```

而`hasOwnProperty`方法是在何处定义的？

```js
console.log(person.hasOwnProperty("hasOwnProperty"));           //false
console.log(person.__proto__.hasOwnProperty("hasOwnProperty")); //false
```

原型对象也是对象，所以它也有原型。当我们使用一个对象的属性或方法时，会在自身中寻找，自身中没有就去原型对象中寻找，如果原型对象中也美有，就去原型对象的原型中去寻找。直到找到`Object`对象的原型。`Object`对象的原型没有原型，如果在`Object`中依然没有找到，则返回`undefined`。

```js
console.log(person.__proto__.__proto__.hasOwnProperty("hasOwnProperty")); //true
```

```js
console.log(person.__proto__);
console.log(person.__proto__.__proto__);
console.log(person.__proto__.__proto__.__proto__);

//output:Node.js
Person { sayName: [Function] }
{}
null
```

#### toString()方法

当我们直接打印一个对象时，实际上是输出对象的`toString()`方法的返回值。该方法定义在原型的原型中。**【有疑问，好像并不是】**

```js
function Person(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
}

var person = new Person("carlos", 20, true);
console.log(person);
console.log(person.__proto__.__proto__.hasOwnProperty("toString"));

//Output: Node.js
Person { name: 'carlos', age: 20, gender: true }
true
```

重写`toString()`方法:

```js
function Person(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
}

Person.prototype.toString = function() {
    return "我叫" + this.name + ",今年" + this.age + "," + (this.gender?"男":"女") + "性."
}

var person = new Person("carlos", 20, true);
console.log(person);
```

### 垃圾回收

就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾，这些垃圾积攒过多以后，会导致程序的运行速度过慢。所以我们需要一个垃圾回收机制来处理程序运行过程中产生的垃圾。

正如之前所讲，变量保存在栈空间，基本数据类型变量的值保存在栈空间，而对象类型变量存储的是一个地址值，该地址值指向一个存储在堆空间上的一个对象空间。通过赋值`null`来切断一个对象变量和堆上对象空间的联系。当一个对象没有任何变量或属性对它进行引用时，此时我们将永远无法操作该对象。这是该对象就是一个垃圾，对于这种对象，如果积累过多占用空间，导致程序变慢，所以必须进行清理。

在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收操作。

### 数组

数组也是一个对象。它和普通的对象功能类似，也是用来存储一些值的，不同的是普通对象是使用字符串作为属性名的，而数组使用的是数字作为**索引**操作元素的。数组的存储性能比对象好，在开发中我们经常使用数组来存储一些数据。

使用`typeof`检查数组对象返回`object`。

```js
var array = new Array();

console.log(array);
console.log(typeof array);

//output:
[]
object
```

向数组中添加元素: `数组[索引] = 值`

```js
var arr = new Array();
arr[0] = 10;
arr[1] = 33;

console.log(arr);    //[ 10, 33 ]
```

读取数组中的元素: `数组[索引]`

```js
var arr = new Array();
arr[0] = 10;
arr[1] = 33;

console.log(arr[0]);  // 10
console.log(arr[2]);  // undefined
```

获取数组中元素的个数: `数组.length`

```js
var arr = new Array();
arr[0] = 10;
arr[1] = 33;
arr[2] = 40;

console.log(arr.length)   // 3
```

对于非连续的数组，使用`length`会获取最大索引加1。尽量不要创建非连续的数组。

```js
var arr = new Array();
arr[0] = 10;
arr[1] = 33;
arr[10] = 10;

console.log(arr);
console.log(arr.length)

//output: Node.js
[ 10, 33, <8 empty items>, 10 ]
11
```

当然，`length`可以自己设置。如果length的长度大于原长度，则多出来的部分会空出来。如果修改的length的长度小于原长度，则会删除多余的元素。

```js
var arr = new Array();
arr[0] = 10;
arr[1] = 33;
arr.length = 10;
console.log(arr);

//output: Node.js
[ 10, 33, <8 empty items> ]
```

```js
var arr = new Array();
arr[0] = 0;
arr[1] = 1;
arr[2] = 2;
arr[3] = 3;
arr[4] = 4;
arr.length = 2;
console.log(arr);

//output: Node.js
[ 0, 1 ]
```

向数组的最后一个位置添加元素: `array[array.length] = value`

```js
var arr = new Array();
arr[0] = 0;
arr[1] = 1;
arr[2] = 3;
arr[arr.length] = 5;
console.log(arr);
arr[arr.length] = 10;
console.log(arr);
arr[arr.length] = 50;
console.log(arr);

//output: Node.js
[ 0, 1, 3, 5 ]
[ 0, 1, 3, 5, 10 ]    
[ 0, 1, 3, 5, 10, 50 ]
```

使用字面量来创建数组:

```js
var arr = [];

console.log(typeof arr);  //object
```

使用字面量来创建数组时，可以在创建时就指定数组中的元素。

```js
var arr = [1, 2, 3, 4, 5, 6, 7];
console.log(arr);

//output: Node.js
[ 1, 2, 3, 4, 5, 6, 7 ]
```

使用构造函数也可以在创建数组时添加元素:

```js
var arr = new Array(10, 20, 30);
console.log(arr);

//output: Node.js
[ 10, 20, 30 ]
```

在使用构造方法时，如果只传递一个数，则时创建长度为该数值的数组。

```js
var arr = new Array(10);
console.log(arr);
console.log(arr.length);

//output: Node.js
[ <10 empty items> ]
10
```

数组中的元素可以是任意数据类型，包括对象、函数、数组。

```js
var obj = {
    name: "carlos",
    age: 10
};
var arr = ['hello', 1, true, null, undefined, obj, {name: "leo", age: 15}];

console.log(arr);

//output: Node.js
[ 'hello',
  1,
  true,
  null,
  undefined,
  { name: 'carlos', age: 10 },
  { name: 'leo', age: 15 } ]
```

```js
var arr = [function(){console.log("Hello")}, function(){alert("Hello")}]
```

```js
var arr = [[1, 2, 3], [null, undefined, "hahaha", new Array()]]
```

#### 数组的方法

* `push()` : 向数组末尾添加一个或多个元素，并返回数组的新的长度。

  ```js
  var arr = ["孙悟空", "猪八戒"];
  var len = arr.push("唐僧");
  len = arr.push("沙悟净", "白骨精");

  console.log(len);
  console.log(arr);

  //output: Node.js
  5
  [ '孙悟空', '猪八戒', '唐僧', '沙悟净', '白骨精' ]
  ```

* `pop()` : 删除并返回数组的最后一个元素

  ```js
  var arr = [ '孙悟空', '猪八戒', '唐僧', '沙悟净', '白骨精' ];
  var ret = arr.pop();
  console.log(ret);
  console.log(arr);

  //output: Node.js
  白骨精
  [ '孙悟空', '猪八戒', '唐僧', '沙悟净' ]
  ```

* `unshift()` : 向数组的开头添加一个会多个元素，并返回新数组的长度。

    ```js
    var arr = ["孙悟空", "猪八戒"];
    var len = arr.unshift("唐僧");
    len = arr.unshift("沙悟净", "白骨精");

    console.log(len);
    console.log(arr);

    //output: Node.js
    5
    [ '沙悟净', '白骨精', '唐僧', '孙悟空', '猪八戒' ]
    ```

* `shift()` : 删除并返回数组的第一个元素。

    ```js
    var arr = [ '孙悟空', '猪八戒', '唐僧', '沙悟净', '白骨精' ];
    var ret = arr.shift();
    console.log(ret);
    console.log(arr);

    //output: Node.js
    孙悟空
    [ '猪八戒', '唐僧', '沙悟净', '白骨精' ]
    ```

* `slice()` : 可以用来从数组中提取指定的元素，返回提取的元素的数组。参数:
    * start : 索引的开始位置，必须有。
    * end : 可选，结束位置的后一个。如果不写，则从start位置开始直到数组结束。

    索引可以传递一个负值，与Python一样的表示。


    ```javascript
    var arr = [ '孙悟空', '猪八戒', '唐僧', '沙悟净', '白骨精' ];
    var result = arr.slice(1, 3);
    console.log(result);
    //output: 
    [ '猪八戒', '唐僧']
    ```

* `splice()` : 用来删除数组中的指定元素。使用`splice()`会影响原数组，会将指定元素从原数组中删除，并返回删除的元素的数组，还可以插入元素，相当于用新元素替换删除的元素。参数:
    * 第一个: start : 开始位置
    * 第二个: number : 删除多少个
    * 第三个及以后: 可以传递一些新的元素，这些元素可以插入到开始位置索引的前边。

    ```javascript
    var arr = [ '孙悟空', '猪八戒', '唐僧', '沙悟净', '白骨精' ];
    var result = arr.splice(1, 2, "牛魔王", "铁扇公主");
    console.log(result);
    console.log(arr);

    //output: Node.js
    [ '猪八戒', '唐僧' ]
    [ '孙悟空', '牛魔王', '铁扇公主', '沙悟净', '白骨精' ]
    ```

* 练习: 删除数组中的重复元素

    ```js
    var array = [1, 2, 3, 2, 2, 1, 3, 4, 2, 5];
    for (var i = 0; i < array.length; i++) {
        for (var j = i + 1; j < array.length; j++) {
            if (array[i] == array[j]) {
                array.splice(j, 1);
                j--;
            }
        }
    }
    console.log(array);

    //output: Node.js
    [ 1, 2, 3, 4, 5 ]
    ```

* `concat()` : 连接两个多个数组，并将新的数组返回，参数可以为多个，既可以是数组，也可以是元素。不会对原数组产生影响，而是返回新的数组。

* `join()` : 该方法可以将数组转换成字符串，将数组中的每个元素连起来，并在每两个之间加入一个连接符，该连接符就是传进来的参数，如果不传入参数，则使用`,`作为连接符。同样不会对原数组产生影响，而是返回一个字符串。

* `reverse()` : 该方法用来反转数组。该方法会直接修改原数组。

* `sort()` : 可以用来对数组中的元素进行排序。会直接改变原数组。默认会按照Unicode编码进行从小到大排序，即使对于纯数字的排序，也会按Unicode编码进行排序。我们可以在`sort()`中给一个回调函数的参数，该回调函数有两个参数a和b。`sort()`会根据回调函数的返回值进行交换位置。

    * 如果回调函数返回值大于0，则交换位置
    * 如果回调函数返回值小于0，则不交换位置
    * 如果回调函数返回值等于0，则表示两个值相等

    ```js
    //Unicode编码码点排序
    var arr = [1, 11, 34, 56, 2, 70, 8];
    arr.sort();
    console.log(arr);

    //升序
    arr.sort(function(a, b) {
        return a - b;
    });
    console.log(arr);

    //降序
    arr.sort(function(a, b) {
        return b - a;
    });
    console.log(arr);

    //output: Node.js
    [ 1, 11, 2, 34, 56, 70, 8 ]
    [ 1, 2, 8, 11, 34, 56, 70 ]
    [ 70, 56, 34, 11, 8, 2, 1 ]
    ```

#### 数组的遍历

* `for`循环遍历

    ```javascript
    var arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"];
    for (var i = 0; i < arr.length; i++) {
        console.log(arr[i]);
    }

    //output: Node.js
    孙悟空
    猪八戒
    沙和尚
    唐僧
    ```

* `forEach`遍历 : 用的比较少，因为IE浏览器的支持不好。`forEach()`方法需要一个参数，参数是一个回调函数。回调函数通常使用匿名函数的形式，调用不由我们自己进行，而是由浏览器调用。浏览器会在回调函数中传递三个参数，第一个是元素，第二个是索引，第三个是正在遍历的数组。

    ```javascript
    var arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"];
    arr.forEach(function(value, index, obj) {
        console.log(value + " " + index + " " + obj);
    });

    //output: Node.js
    孙悟空 0 孙悟空,猪八戒,沙和尚,唐僧
    猪八戒 1 孙悟空,猪八戒,沙和尚,唐僧
    沙和尚 2 孙悟空,猪八戒,沙和尚,唐僧
    唐僧 3 孙悟空,猪八戒,沙和尚,唐僧
    ```

### 函数的方法

函数也是对象，`call()`和`apply()`都是函数对象的方法，需要通过函数对象来调用。当对函数对象调用`call()`和`apply()`都会调用函数执行。调用`call()`和`apply()`可以将一个对象指定为第一个参数,即可以修改函数执行时的上下文对象。

```js
function fun() {
    console.log(this);
}

fun();              //Window


fun.call();
fun.apply();

//output: Node.js
Window
Window
Window
```

```js
function fun() {
    console.log(this);
}

fun();   //window

var obj = {};
fun.call(obj);  
fun.apply(obj);
```

`call()`方法第一个参数为函数的执行上下文，之后的参数就是函数的实参。`apply()`方法第一个参数为函数的执行上下文，之后的参数需要使用数组封装起来作为实参。

```js
function fun(a, b) {
    console.log('a = ' + a + ', b = ' + b);
}

fun(2, 3);

var obj = {};
fun.call(obj, 2, 3);
fun.apply(obj, [2, 3]);

//output: Node.js
a = 2, b = 3
a = 2, b = 3
a = 2, b = 3
```

### 参数列表arguments

在调用函数时，浏览器每次都会传递进两个隐含的参数:

* 函数的上下文对象`this`

* 封装实参的对象`arguments`。`arguments`是一个类数组对象，但不是数组，用于保存传递进来的实参。我们即使不定义形参，也可以通过`arguments`来使用实参。`argument[0]`存储第一个实参，`arguments[1]`存储第二个实参，只是有点麻烦。

```js
function fun() {
    console.log(arguments instanceof Array);
    console.log(Array.isArray(arguments));
    console.log(arguments.length);
}
fun("hello", true);

//output:
false
false
2
```

`arguments`有一个属性`callee`，对应一个函数对象，就是当前正在执行的函数对象。

```js
function fun() {
    console.log(arguments.callee == fun);
}

fun();    //true
```

### Date对象

在JS中使用Date对象来表示一个时间。

直接使用构造函数创建一个Date对象，则表示获取当前时间。

```js
var d = new Date();
console.log(d);  

//output: Chrome
Wed Jul 24 2019 09:35:42 GMT+0800 (中国标准时间)
```

构造函数中可以传递一个表示时间的字符串作为参数，但是有一定的格式。

```js
var d = new Date('12/14/2016');
console.log(d);
d = new Date('12/14/2016 11:10:20');
console.log(d);

//output: Chrome
Wed Dec 14 2016 00:00:00 GMT+0800 (中国标准时间)
Wed Dec 14 2016 11:10:20 GMT+0800 (中国标准时间)
```

#### Date对象的方法

方法 | 描述
-- | --
`getDate()` | 获取当前日期对象的日(1~31)
`getDay()` | 表示当前日期是一周中的第几天(0~6)，0表示周日
`getMonth()` | 获取当前对象的月份(0~11)
`getFullYear()` | 获取当前对象的完整年份(4位数)
`getHours()` | 获取当前对象的小时(0~23)
`getMinutes()` | 获取当前对象的分钟(0~59)
`getSeconds()` | 获取当前对象的秒数(0~59)
`getTime()` | 获取从1970年1月1日至当前对象所指时间所经历的毫秒数
`setDate()` | 设置日期，精确到天
`setFullYear()` | 设置年份，四位数
`setHours()` | 设置小时(0~59)
`setMonth()` | 设置月份(0~11)
`setMinutes()` | 设置分钟(0~59)
`setSeconds()` | 设置秒数(0~59)
`setTime()` | 设置时间戳，毫秒数
`toDateString()` | 将Date对象的日期部分转换为字符串
`toLocaleDateString()` | 根据本地时间将Date对象的日期部分转换为字符串
`toLocaleTimeString()` | 根据本地时间将Date对象的时间部分转换为字符串
`toLocaleString()` | 根据本地时间将Date对象的日期和时间部分转换为字符串
`toUTCString()` | 根据世界时间将Date对象的日期和时间部分转换为字符串
`Date.now()` | 获取当前的时间戳

### Math对象

Math和其他的对象不同，它不是一个构造函数，它属于一个工具类，不用创建对象。Math封装了数学运算相关的属性和方法。

```js
console.log(Date);
console.log(Math);

//output: Chrome
Date() { [native code] }
Math {abs: ƒ, acos: ƒ, acosh: ƒ, asin: ƒ, asinh: ƒ, …}
```

#### Math中的常量

常量 | 描述
-- | --
E | 算数常量e，即自然对数的底数
LN2 | ln2
LN10 | ln10
LOG2E | 以2为底e的对数
LOG10E | 以10为底e的对数
PI | 圆周率
SQRT1_2 | 2的算数平方根的倒数
SQRT2 | 2的算数平方根


#### 方法

方法 | 描述
-- | --
abs(x) | 绝对值
acos(x) | 反余弦值
asin(x) | 反正弦值
atan(x) | 反正切值
ceil(x) | 向上取整
floor(x) | 向下取整
cos(x) | 余弦值
sin(x) | 正弦值
exp(x) | e的x次方
log(x) | 以e为底x的对数
max(x, y) | 最大值
min(x, y) | 最小值
pow(x, y) | x的y次幂
random() | 0~1之间的随机数，不包括0和1
round(x) | 四舍五入为整数
sqrt(x) | 算数平方根
tan(x) | 正切值
toSource() | 返回该对象的源代码
valueOf() | 返回Math对象的原始值

#### 生成x~y之间的随机数

```js
Math.round(Math.random * (y - x)) + x;

//0 ~ 10
Math.round(Math.random * 10);

//1 ~ 10
Math.random(Math.random * 9) + 1;
```

### 包装类

在JavaScript中提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象。对象比基本数据类型要强大。

* String() : 可以将基本数据类型字符串转换为String对象

* Number() : 可以将基本数据类型number类型转换为Number对象

* Boolean() : 可以将基本数据类型boolean类型转换为Boolean对象

```js
var a = 123;
console.log(typeof a);

var num = new Number(123);
console.log(typeof num);

var bool = new Boolean(true);
console.log(typeof bool);

var s = new String("hello");
console.log(typeof s);
//output: Chrome
number
object
object
object
```

注意，我们在实际开发中不会使用包装类型的对象。如果使用包装类型的对象，在比较时，可能会带来不可预期的结果。

另外，当我们对基本数据类型的值或变量去访问属性或调用方法时，浏览器会自动将其进行包装成对象类型，再访问对象的属性或调用对象的方法。看下面的例子:

```js
var a = 123;
console.log(a);
console.log(typeof a);

a.hello = "123";
console.log(a.hello);

//output: Chrome
123
number
undefined
```

上面代码中的`a.hello = "123"`这一步进行了一次包装，但是添加`hello`属性后对象被销毁了。打印`a.hello`时再次进行了包装，该包装对象没有`hello`属性。

### 字符串方法

在底层字符串是以**字符数组**的形式保存的。

#### 属性

* `length` : 获取字符串的长度。

#### 方法

方法 | 描述
-- | --
charAt(index) | 返回指定位置的字符。根据索引获取指定字符。也可以用`[]`来取。
charCodeAt(index) | 返回指定位置字符的Unicode编码
String.fromCharCode(code) | 从Unicode编码获取字符
concat() | 用来连接两个或多个字符串，返回连接后的字符串。
indexOf() | 获取指定子串在原串中的第一个位置的索引，如果没有找到则返回-1。可以指定第二个参数start，即从何处开始
lastIndexOf() | 获取指定子串在原串中的最后位置的索引，如果没找到则返回-1。可以指定第二个参数start，即从何处开始
slice(start, end) | 从字符串中截取指定的内容。不会影响原字符串，返回截取到的内容。包括start位置的字符，但不包括end位置的字符。第二个参数可以省略，如果省略第二个参数，则会截取到末尾。也可以传递负数作为参数，从后面计算，类似Python
substring(start, end) | 可以用来截取指定位置的字符串并返回，与slice()类似。start为开始位置的索引，包括在子串内，end为结束位置的索引，不包括在子串内。与slice()不同的是，该方法不能传递负值，如果传递复制，则使用0代替。而且会自动调整参数的位置，即如果第二个参数位置小于第一个，则自动交换。
replace(reg, newString) | 将匹配到的子串替换为新的字符串。默认只会替换第一个，因此需要使用正则表达式作为参数并开启全局匹配模式。
match(reg) | 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来。注意，是传入一个正则表达式对象，可以使用字面量，也可以传入一个正则对象。默认情况下只会找到第一个符合要求的内容，找到以后就停止检索。我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容。同时，会将找到的内容以数组的形式返回。(开启全局匹配才会提取所有符合的内容，否则只提取第一个就结束)
search(reg) | 搜索字符串中是否有指定的内容。如果搜索到指定内容，返回第一次出现的索引，如果没有搜索到，返回-1。它可以接收一个正则表达式作为一个参数，然后根据正则表达式检索字符串。注意，是传入一个正则表达式对象，可以使用字面量，也可以传入一个正则对象。(即使设置全局匹配，还是查找第一个)
splite(reg) | 将字符串使用指定的分割符拆分成字符串数组，默认使用`,`拆分，可以使用正则表达式指定分隔符。注意，是传入一个正则表达式对象，可以使用字面量，也可以传入一个正则对象。(即使不指定全局匹配，也会全部进行拆分。)
substr(start, len) | 从start开始截取len个字符，对原字符串没有影响。但是EMACscript反对使用该方法。
toLowerCase() | 返回字符串的小写形式
toUpperCase() | 返回字符串的大写形式

### 正则表达式

正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式来检查一个字符串是否符合规则，获取字符串中符合规则的内容提取出来。

创建正则表达式: `var 变量 = new RegExp("正则表达式", "匹配规则");`使用`typeof`检查正则表达式对象，返回`object`。

`test()`方法用于检查一个字符串中是否符合正则表达式的规则，如果符合返回`true`，否则返回`false`。

```js
var reg = new RegExp("a");
var str = "a";
console.log(reg.test(str));          //true
console.log(reg.test("abc"));        //true
console.log(reg.test("bcab"));       //true
console.log(reg.test("bcd"));        //true
```

在上面的正则表达式创建过程中，只提供了一个参数，这是`test()`所做的检查就是查看字符串中是否有该正则表达式的匹配字符串。

还可以在创建正则表达式对象时提供第二个参数，即**匹配模式**:

* `"i"` : 忽略大小写(ignore)
* `"g"` : 全局匹配(global)

使用字面量创建正则表达式: `var 变量 = /正则表达式/匹配模式`

```js
var reg = /a/i;
console.log(reg.test("abc"));   //true
```

创建一个正则表达式，检查一个字符串中是否有a或b，使用`|`

```js
var reg = /a|b/;
```

创建一个正则表达式，检查一个字符串是否有字母。`[]`里的内容也是或的关系。`[a-z]`表示任意小写字母，`[A-Z]`代表任意大写字母。

```js
var reg = /[a-zA-Zs]/
```

`[^..]`表示除了`..`，如:

```js
var reg = /[^ab]/;
console.log(reg.test("ab"));  //false
console.log(reg.test("abc"))  //true
```

注意: 使用构造函数时参数是一个字符串，而`\`是字符串中的转移字符，因此要使用`\`转移时需要使用`\\`。

#### 正则表达式语法

量词只对前面的一个内容起作用。

量词 | 描述
-- | --
{n} | 连续n次
{m, n} | 连续m~n次
{n, } | 连续n次以上
+ | 大于等于1次，相当于{1, }
* | 大于等于0次，相当于{0, }
? | 0次或1次，相当于{0, 1}
^ | 开头，如`/^a/`
$ | 结尾，如`/a$/`，注意`/^a$/`只能匹配`"a"`

练习: 手机号码的正则表达式

```js
/^1[3-8][0-9]{9}$/
```

#### 元字符

元字符是拥有特殊含义的字符。

元字符 | 描述
-- | --
. | 任意字符，检查`.`使用`\.`转义字符
\w | 单词符号(字母、数字、下划线)
\W | 非单词符号
\s | 空白字符
\S | 除了空白字符
\d | 数字(`[0-9]`)
\D | 非数字(`[^0-9]`)
\b | 单词边界，标识一个独立的单词
\B | 非单词边界

练习: 删除首尾空格

```js
str = "    Carlos Leo   ";
str = str.replace(/^\s*|\s$/g, "");
console.log(str);

//output: Chrome
Carlos Leo
```

#### 邮箱的正则表达式

任意字母数字下划线.任意数字字母下划线@任意字母数字.任意字母(2-5位)

```js
reg = /^\w{3,}(\.\w+)*@[A-z0-9]+(.[A-z]{2,5}){1,2}$/;
```

### DOM

__DOM__(Document Object Model, 文档对象模型)，是针对XML但经过扩展用于HTML的应用程序编程接口(API)。DOM把整个页面映射为一个多层节点结构。HTML或XML页面中的每个组成部分都是某种类型的**节点**，这些节点又包含着不同类型的数据。

```html
<html>
    <head>
        <title>Samplt</title>
    </head>
    <body>
        <p>Hello World!</p>
    </body>
</html>
```

分层节点图:

```console
html
  |
  |----head
  |      |
  |      |----title
  |              |
  |              |----Sample
  |
  |
  |----body
         |
         |----p
              |
              |----Hello World!
```

**节点**: 是构成网页的最基本组成部分，网页中的每一个部分都是一个节点，如标签、属性。节点的分类如下:

1. 文档节点: 整个HTML文档
2. 元素节点: HTML文档中的标签
3. 属性节点: 元素的属性
4. 文本节点: HTML标签中的文本内容

以上四类又成节点对象。节点的属性:

节点类型 | nodeName | nodeType | nodeValue
-- | -- | -- | --
文档节点 | #document | 9 | null
元素节点 | 标签名 | 1 | null
属性节点 | 属性名 | 2 | 属性值
文本节点 | #text | 3 | 文本内容

#### 文档节点

浏览器已经为我们提供文档节点对象`document`，这个对象是`window`的属性，可以在页面中直接使用，文档节点代表的是整个网页。

#### 元素节点

通过文档对象获取元素对象:

* 根据`id`获取一个元素节点对象: `document.getElementById(id)`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <button id="btn">我是一个按钮</button>
    <script type="text/javascript">
        var btn = document.getElementById("btn"); // 获取元素节点对象
        console.log(btn);
        console.log(btn.nodeName + ", " + btn.nodeType + ", " + btn.nodeValue);
    </script>
</body>
</html>
```

```console
   <button id="btn">我是一个按钮</button>
BUTTON, 1, null
```

* 根据标签名获取一组元素节点对象: `document.getElementsByTagName(tagName)`

* 根据name属性获取一组元素节点对象: `document.getElementsByName(name)`，常用于表单中的元素。

* 根据class属性获取一组元素节点对象: `document.getElementsByClassName(className)`

当获取到一个元素对象之后，如果想要取该元素对象的属性值，则可以通过`对象名.属性名`来访问，但是除了`class`属性之外，访问`class`属性需要使用`对象名.className`来访问。

### 事件

**事件**，就是文档或浏览器窗口中发生的一些特定的交互瞬间。JavaScript通过事件与网页进行交互。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <button id="btn" onclick="alert('You clicked me');">我是一个按钮</button>
</body>
</html>
```

```js
var btn = document.getElementById("btn");
btn.onclick = function() {
    alert("You clicked me.");
};
```
### 文档的加载

看一个例子:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script type="text/javascript">
        var btn = document.getElementById("btn");
        btn.onclick = function() {
            alert("You clicked me.");
        };
    </script>
</head>
<body>
    <button id="btn" onclick="alert('You clicked me');">我是一个按钮</button>
</body>
</html>
```

上面的代码会报错！！！浏览器在加载一个页面时，是按照自上而下的顺序加载的，读取到一行就运行一行。如果`script`标签写到页面的上边，在代码执行时。将JS代码编写到页面的下部就是为了可以在页面加载完毕后再执行JS代码。

`onload`事件会在整个页面加载完成之后才触发，该事件可以绑定给`img`、`window`，因此可以为`window`绑定一个`onload`事件以实现脚本的延迟执行:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script type="text/javascript">
        window.onload = function() {
            var btn = document.getElementById("btn");
            btn.onclick = function() {
                alert("You clicked me.");
            };
        };
    </script>
</head>
<body>
    <button id="btn" onclick="alert('You clicked me');">我是一个按钮</button>
</body>
</html>
```

如果将`script`写在`head`中，会先下载、执行该`script`中的代码，然后再加载页面，这样就会延迟页面的显示。现代Web开发一般都写在下面。